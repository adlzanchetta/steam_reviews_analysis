import argparse
import requests
import json
import sys
import os


# ## BASIC CHECK ##################################################################################################### #

if int(sys.version[0]) != 3:
    sys.exit("You are not using Python 3. You don't deserve to use this script. Shame on you.")

# ## ARGS ############################################################################################################ #

parser = argparse.ArgumentParser(description='This script harvests timeseries of concurrent players from Valve\'s Steam API.')
parser.add_argument('-input_file', type=str, required=True, metavar='I',
                    help="Mandatory. Path of the input .json file with the list of APPs to be harvested.\n"
                         "This file can be generated by the app_selector.py script.")

parser.add_argument('-output_file', type=str, required=True, metavar='O',
                    help="Mandatory. Path of the output .json file that will be written with the timeseries retrieved.")
args = parser.parse_args()


# ## CONS ############################################################################################################ #

CONCURRENT_MAX_FRAME = "https://steamdb.info/api/GetGraph/?type=concurrent_max&appid=%s"
HTTP_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36'
DEFAULT_FILE_NAME = "concurrent_players.json"


# ## DEFS ############################################################################################################ #

def set_up_output_file_path(path):
    """
    Just ensure we end up with a correct .json file path to write in.
    :param path: String. A system path that can be either a folder path of a .json file path.
    :return: String. The ultimate output file path.
    """
    if os.path.isdir(path):
        return os.path.join(path, DEFAULT_FILE_NAME)
    elif path.endswith('.json'):
        return path
    else:
        sys.exit("Output path is not a valid directory and is not a .json file path.")


def main():
    """
    C-style main function.
    :return: None.
    """

    # read input file
    with open(args.input_file, "r") as r_file:
        all_apps = json.load(r_file)

    # vanilla loop for retrieving timeseries one-by-one
    out_dict = {}
    print("Exploring %d apps." % len(all_apps.keys()))
    for appid in all_apps.keys():
        try:
            url = CONCURRENT_MAX_FRAME % appid
            out_dict[appid] = requests.get(url, headers={'User-Agent': HTTP_AGENT}).json()['data']
        except (json.decoder.JSONDecodeError, KeyError):
            print(" Invalid return from %s" % url)
            continue

    # write file if it woths to
    if len(out_dict.keys()) <= 0:
        sys.exit("Did not retrieve any information. No file written.")
    output_file_path = set_up_output_file_path(args.output_file)
    with open(output_file_path, "w") as w_file:
        json.dump(out_dict, w_file, indent=4, sort_keys=True)
    print("Wrote: %s" % output_file_path)


# ## CALL ############################################################################################################ #

if __name__ == '__main__':
    main()
